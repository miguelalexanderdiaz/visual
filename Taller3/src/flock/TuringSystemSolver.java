package flock;

import java.util.Random;

/**
 * Solve Turing Reaction-Diffusion equations. double math and a single separate
 * thread. A {@link TuringSystemSolver.ResultListener} will be notified of
 * interim and final results.
 */
class TuringSystemSolver {
	/**
	 * A listener interface for events generated by a {@link TuringSystemSolver}
	 * .
	 */
	interface ResultListener {
		/**
		 * An event generated by a {@link TuringSystemSolver} whenever a new
		 * result is available. The value of <code>iteration</code> may be used
		 * to determine if it is an initial, final, or interim result. The
		 * current state of the system is passed in <code>result</code>, which
		 * is an array of the same size as the requested width and height of the
		 * system. This array should be considered read-only.
		 *
		 * @param iteration
		 *            the iteration number represented by this result, from 0 to
		 *            the total iterations requested
		 * @param result
		 *            an array representing the current system state
		 */
		void solverResultEvent(int iteration, double[][] result);
	}

	private int iterations;
	private double CA, CB;
	private volatile Thread solveThread;

	public TuringSystemSolver(ResultListener listener, int width, int height) {
		this.listener = listener;
		Ao = new double[width][height];
		An = new double[width][height];
		Bo = new double[width][height];
		Bn = new double[width][height];
		this.width = width;
		this.height = height;
	}

	public void solve(int iterations, double CA, double CB) {
		// if (Thread.currentThread() == solveThread) {
		// throw new AssertionError("called solve() from solveThread");
		// }
		//
		// stop();
		this.iterations = iterations;
		this.CA = CA;
		this.CB = CB;
		// solveThread = new Thread(new Runnable() {
		// @Override
		// public void run() {
		solveImpl();
		// }
		// });
		// solveThread.start();
	}

	private void solveImpl() {
		int n, i, j, iplus1, iminus1, jplus1, jminus1;
		double DiA, ReA, DiB, ReB;

		long lastUpdateTime = System.nanoTime(), currentTime;
		int lastUpdateFrame = 0;

		// uses Euler's method to solve the diff eqns
		for (n = 0; n < iterations; ++n) {
			for (i = 0; i < height; ++i) {
				// treat the surface as a torus by wrapping at the edges
				iplus1 = i + 1;
				iminus1 = i - 1;
				if (i == 0) {
					iminus1 = height - 1;
				}
				if (i == (height - 1)) {
					iplus1 = 0;
				}

				for (j = 0; j < width; ++j) {
					jplus1 = j + 1;
					jminus1 = j - 1;
					if (j == 0) {
						jminus1 = width - 1;
					}
					if (j == (width - 1)) {
						jplus1 = 0;
					}

					// Component A
					DiA = CA * ((((Ao[iplus1][j] - (2.0 * Ao[i][j])) + Ao[iminus1][j]
							+ Ao[i][jplus1]) - (2.0 * Ao[i][j])) + Ao[i][jminus1]);
					ReA = (Ao[i][j] * Bo[i][j]) - Ao[i][j] - 12.0;
					An[i][j] = Ao[i][j] + (0.01 * (ReA + DiA));
					if (An[i][j] < 0.0) {
						An[i][j] = 0.0;
					}

					// Component B
					DiB = CB * ((((Bo[iplus1][j] - (2.0 * Bo[i][j])) + Bo[iminus1][j]
							+ Bo[i][jplus1]) - (2.0 * Bo[i][j])) + Bo[i][jminus1]);
					ReB = 16.0 - (Ao[i][j] * Bo[i][j]);
					Bn[i][j] = Bo[i][j] + (0.01 * (ReB + DiB));
					if (Bn[i][j] < 0.0) {
						Bn[i][j] = 0.0;
					}
				}
			}

			// The visualizer will be updated whenever UPDATE_RATE_FRAMES
			// iterations
			// have been calculated, or when the time since the last update
			// has been at least UPDATE_RATE_TIME nanoseconds (whichever happens
			// first).
			// currentTime = System.nanoTime();
			// if (((currentTime - lastUpdateTime) >= UPDATE_RATE_TIME)
			// || ((n - lastUpdateFrame) >= UPDATE_RATE_FRAMES)) {
			// lastUpdateTime = currentTime;
			// lastUpdateFrame = n;
			// sendFrameToListener(n, An);
			// }
			// Swap Ao for An, Bo for Bn
			swapBuffers();
		}
		// send the final data set to be displayed
		sendFrameToListener(n, An);
		// solveThread = null;
	}

	/**
	 * Stop an in-progress solution, if any.
	 */
	public synchronized void stop() {
		if (Thread.currentThread() == solveThread) {
			throw new AssertionError("called stop() from solveThread");
		}

		Thread thread = solveThread;
		if (thread != null) {
			solveThread = null;
			thread.interrupt();

			boolean killed = false;
			while (!killed) {
				try {
					thread.join();
					killed = true;
				} catch (InterruptedException e) {
				}
			}
		}
	}

	/**
	 * Set the system to an initial noise state. This should normally called
	 * before solving.
	 */
	public void randomize() {
		stop();
		for (int i = 0; i < height; ++i) {
			for (int j = 0; j < width; ++j) {
				Ao[i][j] = (rand.nextDouble() * 12.0) + (rand.nextGaussian() * 2.0);
				Bo[i][j] = (rand.nextDouble() * 12.0) + (rand.nextGaussian() * 2.0);
			}
		}
		sendFrameToListener(0, Ao);
	}

	private void swapBuffers() {
		double[][] temp = Ao;
		Ao = An;
		An = temp;
		temp = Bo;
		Bo = Bn;
		Bn = temp;
	}

	/**
	 * Sends the current system state to the listener.
	 */
	protected void sendFrameToListener(int iteration, double[][] data) {
		// for efficiency and simplicity, we do not send a copy of A;
		// that means that the listener can modify our data
		// if this is a concern, clone the array before sending
		listener.solverResultEvent(iteration, data);
	}

	private ResultListener listener;
	// System state at the old (Ao, Bo) and new (An, Bn) time steps.
	private double[][] Ao, Bo, An, Bn;
	private int width, height;
	private Random rand = new Random();

	/** Maximum number of iterations between update frames. */
	protected static final int UPDATE_RATE_FRAMES = 20;
	/** Maximum number of nanoseconds between update frames. */
	protected static final long UPDATE_RATE_TIME = 200000000L;
}
